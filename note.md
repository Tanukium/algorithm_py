# Pyアルゴリズム

1. 変な使い方1

```
“abc % i” % 123 -> “abc123”
```

2. 運算優先順位：べき>乗除>加減>比較>論理

3. 内包表記

```
lst = [for i in range(0,10)] # ==[0,…,9]
lst = [for i in range(0,10) # ==[0,2,4,6,8]
       if i % 2 == 0] 
lst = [if i % 2 == 0 else 0
      for i in range(0,10)] 
      # ==[0,0,2,0,4,0,6,0,8,0]
```

4. （関数定義時）関数内グローバル呼び出し
  * ローカルとして認識
  * 関数呼び出し時廃棄

5. 変な使い方2

`sys.exit() # 美感がない`

6. 素数1

```
def is_prime(n):
    ....
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0
            return False
    return True
```

7. 連結リスト：[値,**アドレス**] -> [値, **アドレス**]
  * 計算量：挿入O(1), 削除O(1) `# 前提：位置確定済`

8. クラスP, NP, NP-d
  * P -> O(an+b), 多項式時間内解ける
    * リスト／連結リスト操作, etc.
  * NP -> O(n^x), **非決定性**多項式時間内解ける
    * ナップザック, etc.
    * NP解くにはアルゴリズムが必要だが, 現在ない
  * NP-d -> NP困難, eg: O(n!)
    * NPと同様（NP以上）計算量が膨大だが,NP-d not in NP
    * 巡回セールスマン, etc.

9. 線形探索

```
lst = [a,b,c,…]
for i in lst:
    if n == i:
        return True
```

  * 計算量：平均O((n+1)/2) -> O(n)?, 最大O(n)
  
10. 二分探索
  * 事前にデータ並べ替え必要, 大量データに向ける 
  * O(log n)

11. 木探索: `# range(0,15)の完全二分木を例として`
	1. 幅優先, 深さ優先
	2. 幅優先: 同じレイヤーのノードを優先走査
    * `[[0],[1,2],[3,4,5,6],[7,8,9,10,11,12,13,14]]`
	3. 深さ優先: 再帰的に親ノード -> 子ノード
    * 行きがけ, 帰りがけ, 通りがけ
    * 行きがけ: `0,1,3,7,8,4,9,10,2,5,11,12,6,13,14`
    * 帰りがけ: `7,8,3,9,10,4,1,11,12,5,13,14,6,2,0`
    * 通りがけ: `7,3,8,1,9,4,10,0,11,5,12,2,13,6,14`
	4. 実装: 
    * 木:  `[[1,2],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[]*8]`  -> `# ノード数の配列`
    * 幅: 一時容器(配列)にルートを置く, 容器からノードを`pop`して`pos`にする, 判定`pos`, `木[pos]`のメンバーを容器に`append`.
    * 深: 
      * 行きがけ: (1)関数化(引数`pos`), (2)判定`pos`, (3)`木[pos]`のメンバーに再帰関数引用.
      * 帰りがけ: (1), (3), (2)
      * 通りがけ: (1), 

```
if len(tree[pos]) == 2:  # 子が2つあるとき
    search(tree[pos][0]) # (3)
    print(pos, end=' ')  # (2)左のノードと右のノードの間に出力
    search(tree[pos][1]) # (3)
elif len(tree[pos]) == 1:  # 子が1つのとき
    search(tree[pos][0]) # (3)
    print(pos, end=' ')  # (2)左のノードを調べた後に出力
else:  # 配下のノードがないとき
    print(pos, end=' ') # (3)
```

